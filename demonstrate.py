#!/usr/bin/env python3
"""
Quantum-SaaS Encryption Protocol using Qiskit
Version 1.0 - Based on True Quantum Randomness

Author: Adapted by AI from Jacobo Tlacaelel's concept.
Concept: This protocol replaces simulated radioactive decay with true quantum randomness
         generated by a quantum computer (or simulator) via Qiskit. It follows a
         Software-as-a-Service (SaaS) model where a central service provides
         quantum-generated keys.
"""

import hashlib
import base64
import time
from dataclasses import dataclass
from typing import Tuple

# --- Qiskit Imports ---
# We use the Aer simulator for local testing. This can be swapped for a real quantum backend.
from qiskit import QuantumCircuit, transpile
from qiskit.aer import AerSimulator

# --- Core Classes for the Quantum-SaaS Protocol ---

class QuantumEntropySource:
    """
    Represents the core quantum hardware (or simulator) that generates random bits.
    This class replaces the `GeneradorRuidoDecaimiento` from the original code.
    """
    def __init__(self):
        # Initialize the simulator. In a real SaaS, this would be a connection
        # to actual quantum hardware.
        self.simulator = AerSimulator()
        print("‚úÖ Quantum Entropy Source Initialized (using Qiskit Aer Simulator).")

    def generate_random_bits(self, num_bits: int) -> str:
        """
        Generates a string of random bits using a quantum circuit.

        Args:
            num_bits: The number of random bits to generate.

        Returns:
            A string of '0's and '1's.
        """
        # 1. Create a quantum circuit with `num_bits` qubits and `num_bits` classical bits.
        qc = QuantumCircuit(num_bits, num_bits)

        # 2. Apply a Hadamard gate to each qubit. This puts them in an equal
        #    superposition of |0> and |1>, making the measurement outcome purely random.
        for i in range(num_bits):
            qc.h(i)

        # 3. Measure each qubit and store the result in the corresponding classical bit.
        qc.measure(range(num_bits), range(num_bits))

        # 4. Transpile the circuit for the target backend for optimization.
        t_qc = transpile(qc, self.simulator)

        # 5. Run the job on the simulator. We only need 1 "shot" as each measurement
        #    in the shot is an independent random event.
        job = self.simulator.run(t_qc, shots=1, memory=True)
        result = job.result()

        # 6. Extract the memory (the classical bit outcomes). It returns a list like ['10110'].
        #    We take the first and only result from our single shot.
        random_bits = result.get_memory(t_qc)[0]

        return random_bits

@dataclass
class QuantumKey:
    """
    A cryptographic key derived from a true quantum process.
    This replaces the original `ClaveQuantica`.
    """
    key_hex: str
    length_bits: int
    timestamp: float
    quantum_backend_name: str
    entropy_source_bits: str # The raw bits from the quantum computer

    def __repr__(self):
        return (f"QuantumKey(key_hex='{self.key_hex[:16]}...', "
                f"length={self.length_bits} bits, backend='{self.quantum_backend_name}')")


class QuantumSaaSCryptoService:
    """
    The main SaaS provider. It offers key generation and cryptographic services
    to clients, backed by a quantum entropy source.
    """
    def __init__(self):
        self.entropy_source = QuantumEntropySource()
        self.key_history = []
        print("üöÄ Quantum-SaaS Cryptography Service is now online.")

    def generate_quantum_key(self, length_bits: int = 256) -> QuantumKey:
        """
        Generates a secure cryptographic key for a client.

        This is a service endpoint that would be called by clients.
        """
        print(f"\n[Service] Key request received for {length_bits} bits.")
        print("[Service] Accessing Quantum Entropy Source...")

        # 1. Get raw random bits from the quantum source.
        raw_bits = self.entropy_source.generate_random_bits(length_bits)
        print(f"[Service] Raw quantum bits received: {raw_bits[:32]}...")

        # 2. Perform "Entropy Extraction". We hash the raw quantum data to produce
        #    a final key of a fixed length. This is a standard practice to
        #    smooth out any potential (though unlikely) biases from the hardware.
        raw_bytes = int(raw_bits, 2).to_bytes(length_bits // 8, byteorder='big')
        key_hash = hashlib.sha256(raw_bytes).hexdigest()

        # 3. Create the key object.
        key = QuantumKey(
            key_hex=key_hash,
            length_bits=256,  # SHA-256 produces a 256-bit hash
            timestamp=time.time(),
            quantum_backend_name=self.entropy_source.simulator.name(),
            entropy_source_bits=raw_bits
        )

        self.key_history.append(key)
        print(f"[Service] Secure Quantum Key generated and logged.")
        return key

    def encrypt(self, plaintext: str, key: QuantumKey) -> str:
        """
        Encrypts a message using a quantum-generated key (One-Time Pad style).

        Args:
            plaintext: The message to encrypt.
            key: The QuantumKey to use for encryption.

        Returns:
            Base64 encoded ciphertext.
        """
        plaintext_bytes = plaintext.encode('utf-8')
        key_bytes = bytes.fromhex(key.key_hex)

        # Use XOR cipher. For perfect security, key must be as long as the message.
        # Here, we repeat the key if necessary, which is a common stream cipher approach.
        encrypted_bytes = bytearray()
        for i, byte in enumerate(plaintext_bytes):
            encrypted_bytes.append(byte ^ key_bytes[i % len(key_bytes)])

        # Return as a Base64 string for safe transport
        return base64.b64encode(encrypted_bytes).decode('ascii')

    def decrypt(self, ciphertext_b64: str, key: QuantumKey) -> str:
        """
        Decrypts a message using the corresponding quantum-generated key.
        """
        try:
            ciphertext_bytes = base64.b64decode(ciphertext_b64.encode('ascii'))
            key_bytes = bytes.fromhex(key.key_hex)

            decrypted_bytes = bytearray()
            for i, byte in enumerate(ciphertext_bytes):
                decrypted_bytes.append(byte ^ key_bytes[i % len(key_bytes)])

            return decrypted_bytes.decode('utf-8')
        except Exception as e:
            return f"DECRYPTION_ERROR: {str(e)}"

class Client:
    """
    Represents a client using the Quantum-SaaS for secure communication.
    """
    def __init__(self, service: QuantumSaaSCryptoService, client_id: str):
        self.service = service
        self.id = client_id
        print(f"üë§ Client '{self.id}' connected to the Quantum-SaaS service.")

    def send_secure_message(self, message: str) -> Tuple[str, QuantumKey]:
        """
        Client action to encrypt and "send" a message.
        """
        print(f"\n--- {self.id}: Preparing to send a secure message ---")
        # 1. Client requests a new quantum key from the service.
        print(f"[{self.id}] Requesting a new quantum key from the service...")
        quantum_key = self.service.generate_quantum_key(256)
        print(f"[{self.id}] Quantum Key received: {quantum_key}")

        # 2. Client uses the key to encrypt the message locally.
        print(f"[{self.id}] Encrypting message using the new key...")
        encrypted_message = self.service.encrypt(message, quantum_key)
        print(f"[{self.id}] Message encrypted successfully.")

        # In a real scenario, the encrypted_message and the key (or a key ID)
        # would be sent to the recipient. The key must be shared via a secure channel.
        return encrypted_message, quantum_key

    def receive_secure_message(self, encrypted_message: str, key: QuantumKey) -> str:
        """
        Client action to decrypt a received message.
        """
        print(f"\n--- {self.id}: Received a secure message, attempting to decrypt ---")
        decrypted_message = self.service.decrypt(encrypted_message, key)
        return decrypted_message


# --- Main Demonstration ---

def demonstrate_protocol():
    """Demonstrates the full client-server encryption and decryption flow."""
    print("=" * 60)
    print("üöÄ DEMONSTRATION: Quantum-SaaS Encryption Protocol üöÄ")
    print("=" * 60)

    # 1. The central Quantum SaaS service is started.
    saas_service = QuantumSaaSCryptoService()

    # 2. Two clients, Alice and Bob, connect to the service.
    alice = Client(service=saas_service, client_id="Alice")
    bob = Client(service=saas_service, client_id="Bob")

    # 3. Alice wants to send a secret message to Bob.
    original_message = "The launch code is 1234. Quantum supremacy is near!"

    # 4. Alice uses the service to create an encrypted package.
    #    She requests a key and encrypts her message.
    encrypted_data, key_for_bob = alice.send_secure_message(original_message)

    print("\n--- Transmission ---")
    print(f"Original Message: '{original_message}'")
    print(f"Key (Hex):        {key_for_bob.key_hex}")
    print(f"Encrypted (B64):  {encrypted_data}")
    print("--------------------")

    # In a real QKD protocol like BB84, this key would be securely established
    # between Alice and Bob. For this demo, we assume Alice securely passes
    # `key_for_bob` to Bob.

    # 5. Bob receives the encrypted data and the key. He uses the service
    #    (or its decryption logic) to read the message.
    decrypted_message = bob.receive_secure_message(encrypted_data, key_for_bob)

    print("\n--- Verification at Bob's End ---")
    print(f"Decrypted Message: '{decrypted_message}'")

    # 6. Verification
    if original_message == decrypted_message:
        print("\n‚úÖ SUCCESS: The message was decrypted correctly. The protocol works!")
    else:
        print("\n‚ùå FAILURE: The decrypted message does not match the original.")

    print("\n=" * 60)
    print("üéâ DEMONSTRATION COMPLETE üéâ")
    print("=" * 60)

if __name__ == "__main__":
    demonstrate_protocol()